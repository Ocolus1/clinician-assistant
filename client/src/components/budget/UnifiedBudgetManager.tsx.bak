import React, { useMemo, useState, useEffect } from "react";
import { useForm, useFieldArray } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import * as z from "zod";
import { 
  FIXED_BUDGET_AMOUNT, 
  AVAILABLE_FUNDS_AMOUNT,
  unifiedBudgetFormSchema,
  UnifiedBudgetFormValues,
  budgetItemSchema
} from "./BudgetFormSchema";
import { 
  Form, 
  FormControl, 
  FormField, 
  FormItem, 
  FormLabel, 
  FormMessage 
} from "@/components/ui/form";
import { 
  Card, 
  CardContent, 
  CardDescription, 
  CardFooter, 
  CardHeader, 
  CardTitle 
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { BudgetValidation } from "./BudgetValidation";
import { BudgetItemRow } from "./BudgetItemRow";
import { BudgetCatalogSelector } from "./BudgetCatalogSelector";
import { Separator } from "@/components/ui/separator";
import { formatCurrency } from "@/lib/utils";
import { useToast } from "@/hooks/use-toast";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { apiRequest } from "@/lib/queryClient";
import { useBudgetFeature, BudgetPlan, BudgetItem } from "./BudgetFeatureContext";
import { Loader2, AlertCircle } from "lucide-react";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { CatalogItem, RowBudgetItem } from "./BudgetTypes";

// We're using the budgetItemSchema imported from BudgetFormSchema.ts

// We're using the unifiedBudgetFormSchema directly from BudgetFormSchema.ts

interface UnifiedBudgetManagerProps {
  clientId: number;
}

export function UnifiedBudgetManager({ clientId }: UnifiedBudgetManagerProps) {
  const { toast } = useToast();
  const queryClient = useQueryClient();
  const [formInitialized, setFormInitialized] = useState(false);
  
  // Use the budget feature context
  const { 
    activePlan, 
    setActivePlan, 
    budgetItems, 
    setBudgetItems
  } = useBudgetFeature();

  // Get active budget plan
  const plansQuery = useQuery({
    queryKey: [`/api/clients/${clientId}/budget-settings`],
    queryFn: async () => {
      const response = await fetch(`/api/clients/${clientId}/budget-settings?all=true`);
      if (!response.ok) {
        throw new Error('Failed to fetch budget plans');
      }
      const data = await response.json();
      // Handle both array and single object responses
      return Array.isArray(data) ? data : [data];
    }
  });

  // Get budget items for the active plan
  const itemsQuery = useQuery({
    queryKey: [`/api/clients/${clientId}/budget-items`, activePlan?.id],
    queryFn: async () => {
      if (!activePlan) {
        return [];
      }
      const response = await fetch(`/api/clients/${clientId}/budget-items?budgetSettingsId=${activePlan.id}`);
      if (!response.ok) {
        throw new Error('Failed to fetch budget items');
      }
      return response.json();
    },
    enabled: !!activePlan
  });

  // Get catalog items
  const catalogQuery = useQuery({
    queryKey: ['/api/budget-catalog'],
    queryFn: async () => {
      try {
        const response = await fetch('/api/budget-catalog');
        if (!response.ok) {
          throw new Error('Failed to fetch catalog items');
        }
        const data = await response.json();
        // Return empty array if data is not valid
        return Array.isArray(data) ? data : [];
      } catch (error) {
        console.error('Error fetching catalog items:', error);
        return []; // Return empty array on error for graceful degradation
      }
    },
    retry: 2 // Add retry logic to handle temporary network issues
  });

  // Set active plan from data (first active plan by default)
  useEffect(() => {
    if (plansQuery.data && plansQuery.data.length > 0 && !activePlan) {
      const activePlans = plansQuery.data.filter((plan: any) => plan.isActive);
      if (activePlans.length > 0) {
        setActivePlan(activePlans[0]);
      } else {
        setActivePlan(plansQuery.data[0]);
      }
    }
  }, [plansQuery.data, activePlan, setActivePlan]);

  // Form setup with budget items
  const form = useForm<UnifiedBudgetFormValues>({
    resolver: zodResolver(unifiedBudgetFormSchema),
    defaultValues: {
      items: [],
      totalBudget: 0, // Will be updated with client-specific budget
      totalAllocated: 0,
      remainingBudget: 0 // Will be updated with client-specific budget
    }
  });

  // Initialize form with data when it's available
  useEffect(() => {
    if (itemsQuery.data && activePlan && !formInitialized) {
      const initialItems = itemsQuery.data.map((item: any) => ({
        id: item.id,
        itemCode: item.itemCode,
        description: item.description,
        quantity: item.quantity,
        unitPrice: item.unitPrice,
        total: item.unitPrice * item.quantity,
        name: item.name,
        category: item.category,
        budgetSettingsId: item.budgetSettingsId,
        clientId: item.clientId
      }));
      
      // Total allocated is the sum of all items
      const totalCalculated = initialItems.reduce((sum: number, item: any) => 
        sum + (item.quantity * item.unitPrice), 0);
      
      // Get client-specific budget amounts from the active plan
      // Parse to ensure we're working with numbers instead of strings
      const clientBudgetAmount = activePlan.availableFunds 
        ? (typeof activePlan.availableFunds === 'string' ? parseFloat(activePlan.availableFunds) : activePlan.availableFunds)
        : FIXED_BUDGET_AMOUNT;
      
      console.log('Client budget amount:', clientBudgetAmount);
      
      // Use the client-specific budget amount
      form.reset({
        items: initialItems,
        totalBudget: clientBudgetAmount,
        totalAllocated: totalCalculated,
        remainingBudget: clientBudgetAmount - totalCalculated
      });
      
      setFormInitialized(true);
      setBudgetItems(itemsQuery.data);
    }
  }, [itemsQuery.data, activePlan, form, formInitialized, setBudgetItems]);

  // Field array for dynamic items management
  const { fields, append, remove, update } = useFieldArray({
    name: "items",
    control: form.control
  });

  // Watch values for real-time calculation
  const items = form.watch("items") || [];
  const totalAllocated = useMemo(() => 
    items.reduce((sum, item) => sum + (item.quantity * item.unitPrice), 0),
    [items]
  );
  
  // Update meta fields whenever items change
  useEffect(() => {
    if (activePlan && formInitialized) {
      // Get client-specific budget amount
      const clientBudgetAmount = activePlan.availableFunds 
        ? (typeof activePlan.availableFunds === 'string' ? parseFloat(activePlan.availableFunds) : activePlan.availableFunds)
        : FIXED_BUDGET_AMOUNT;
      
      form.setValue("totalAllocated", totalAllocated);
      form.setValue("remainingBudget", clientBudgetAmount - totalAllocated);
    }
  }, [form, totalAllocated, activePlan, formInitialized]);

  // Handle updating an item's quantity
  const handleUpdateItemQuantity = (index: number, newQuantity: number) => {
    const item = items[index];
    if (item) {
      const updatedItem = {
        ...item,
        quantity: newQuantity,
        total: newQuantity * item.unitPrice
      };
      update(index, updatedItem);
    }
  };

  // Handle deleting an item
  const handleDeleteItem = (index: number) => {
    remove(index);
  };

  // Using CatalogItem from BudgetTypes.ts
  
  // Handle adding a catalog item
  const handleAddCatalogItem = (catalogItem: CatalogItem, quantity: number) => {
    if (!activePlan) return;
    
    // Create a new budget item from catalog item
    const newItem = {
      itemCode: catalogItem.itemCode,
      description: catalogItem.description,
      quantity: quantity,
      unitPrice: catalogItem.defaultUnitPrice,
      total: quantity * catalogItem.defaultUnitPrice,
      isNew: true,
      name: catalogItem.description, // Use description as the name
      category: catalogItem.category !== null ? catalogItem.category : undefined, // Handle null case explicitly
      budgetSettingsId: activePlan.id,
      clientId: clientId
    };
    
    append(newItem);
  };

  // Mutation for saving all changes
  const saveMutation = useMutation({
    mutationFn: async (data: UnifiedBudgetFormValues) => {
      // Check if budget is exceeded
      if (data.remainingBudget < 0) {
        throw new Error("Cannot save: Budget allocation exceeds the maximum allowed amount");
      }
      
      // Ensure items is not undefined
      const items = data.items || [];
      
      // Filter items to update (existing items) and items to create (new items)
      const itemsToUpdate = items.filter(item => !item.isNew && item.id);
      const itemsToCreate = items.filter(item => item.isNew);
      
      // Debug log
      console.log("Items to update:", itemsToUpdate);
      console.log("Items to create:", itemsToCreate);
      
      try {
        const allPromises = [];
        
        // Update existing items
        if (itemsToUpdate.length > 0) {
          const updatePromises = itemsToUpdate.map(item => 
            apiRequest('PUT', `/api/budget-items/${item.id}`, {
              quantity: item.quantity,
              unitPrice: item.unitPrice
            })
          );
          allPromises.push(...updatePromises);
        }
        
        // Create new items
        if (itemsToCreate.length > 0 && activePlan) {
          const createPromises = itemsToCreate.map(item => 
            apiRequest('POST', `/api/budget-items`, {
              clientId: clientId,
              budgetSettingsId: activePlan.id,
              itemCode: item.itemCode,
              description: item.description,
              quantity: item.quantity,
              unitPrice: item.unitPrice,
              name: item.name || item.description,
              category: item.category
            })
          );
          allPromises.push(...createPromises);
        }
        
        // We no longer need to update budget settings as we're using the client-specific values
        // Removed the automatic budget settings update to maintain client budget settings integrity
        }
        
        // Execute all promises or return empty array if no changes
        if (allPromises.length === 0) {
          return [];
        }
        
        const results = await Promise.all(allPromises);
        return results;
      } catch (error) {
        console.error("Error during save operation:", error);
        throw error; // Re-throw to trigger onError handler
      }
    },
    onSuccess: (results) => {
      // If no results returned (no changes made), show different message
      if (results && results.length === 0) {
        toast({
          title: 'No Changes',
          description: 'No changes were detected to save.'
        });
        return;
      }
      
      toast({
        title: 'Success',
        description: 'Budget items updated successfully'
      });
      
      // Invalidate queries to refresh data
      queryClient.invalidateQueries({ 
        queryKey: [`/api/clients/${clientId}/budget-items`] 
      });
      
      queryClient.invalidateQueries({ 
        queryKey: [`/api/clients/${clientId}/budget-settings`] 
      });
      
      // Reset the form initialized state to trigger form refill with fresh data
      setFormInitialized(false);
    },
    onError: (error: any) => {
      toast({
        title: 'Error',
        description: error.message || 'Failed to update budget items',
        variant: 'destructive'
      });
      console.error('Failed to update budget items:', error);
    }
  });

  // Submit handler - focusing on form state tracking and direct API calls
  const onSubmit = async (data: UnifiedBudgetFormValues) => {
    // Prevent double submission
    if (saveMutation.isPending) {
      return;
    }
    
    try {
      // Show saving indicator immediately for user feedback
      toast({
        title: 'Processing',
        description: 'Checking budget changes...'
      });
      
      // Get the original items from the database to compare
      const response = await fetch(`/api/clients/${clientId}/budget-items`);
      const originalItems = await response.json();
      
      // Identify which items have actually changed
      const changedItems = data.items.filter(formItem => {
        if (formItem.isNew) return true; // New items are always changes
        
        // Find the matching original item
        const originalItem = originalItems.find((o: any) => o.id === formItem.id);
        if (!originalItem) return true; // If not found in original, consider it changed
        
        // Compare the quantity and unitPrice to detect changes
        // Convert to numbers to ensure proper comparison
        const formItemUnitPrice = typeof formItem.unitPrice === 'string' ? 
          parseFloat(formItem.unitPrice) : formItem.unitPrice;
          
        const originalItemUnitPrice = typeof originalItem.unitPrice === 'string' ? 
          parseFloat(originalItem.unitPrice) : originalItem.unitPrice;
          
        return formItem.quantity !== originalItem.quantity || formItemUnitPrice !== originalItemUnitPrice;
      });
      
      // If nothing actually changed, show message and exit
      if (changedItems.length === 0) {
        toast({
          title: 'No Changes',
          description: 'No changes detected to save.'
        });
        return;
      }
      
      // Separate items by operation type
      const itemsToUpdate = changedItems.filter(item => !item.isNew && item.id);
      const itemsToCreate = changedItems.filter(item => item.isNew);
      
      // Show saving toast
      toast({
        title: 'Saving Changes',
        description: 'Updating budget allocations...'
      });
      
      // Create a log for debugging
      console.log('Original items:', originalItems);
      console.log('Changed items:', changedItems);
      console.log('Items to update:', itemsToUpdate);
      console.log('Items to create:', itemsToCreate);
      
      // Execute API calls in sequence to avoid race conditions
      
      // 1. Update existing items first
      let updateSuccess = true;
      for (const item of itemsToUpdate) {
        try {
          const updateResponse = await fetch(`/api/budget-items/${item.id}`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              quantity: item.quantity,
              unitPrice: item.unitPrice
            }),
          });
          
          if (!updateResponse.ok) {
            throw new Error(`Failed to update item ${item.id}: ${updateResponse.status}`);
          }
          
          console.log(`Successfully updated item ${item.id}`);
        } catch (err) {
          console.error(`Failed to update item ${item.id}:`, err);
          updateSuccess = false;
        }
      }
      
      // 2. Create new items 
      let createSuccess = true;
      if (activePlan) {
        for (const item of itemsToCreate) {
          try {
            const createResponse = await fetch(`/api/budget-items`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                clientId: clientId,
                budgetSettingsId: activePlan.id,
                itemCode: item.itemCode,
                description: item.description,
                quantity: item.quantity,
                unitPrice: item.unitPrice,
                name: item.name || item.description,
                category: item.category
              }),
            });
            
            if (!createResponse.ok) {
              throw new Error(`Failed to create new item: ${createResponse.status}`);
            }
            
            console.log('Successfully created new item');
          } catch (err) {
            console.error(`Failed to create new item:`, err);
            createSuccess = false;
          }
        }
      }
      
      // 3. Update budget settings if needed
      let settingsUpdateSuccess = true;
      if (activePlan && activePlan.availableFunds !== AVAILABLE_FUNDS_AMOUNT) {
        try {
          const settingsResponse = await fetch(`/api/budget-settings/${activePlan.id}`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              availableFunds: AVAILABLE_FUNDS_AMOUNT
            }),
          });
          
          if (!settingsResponse.ok) {
            throw new Error(`Failed to update budget settings: ${settingsResponse.status}`);
          }
          
          console.log('Successfully updated budget settings');
        } catch (err) {
          console.error(`Failed to update budget settings:`, err);
          settingsUpdateSuccess = false;
        }
      }
      
      // Refresh data
      queryClient.invalidateQueries({ 
        queryKey: [`/api/clients/${clientId}/budget-items`] 
      });
      
      queryClient.invalidateQueries({ 
        queryKey: [`/api/clients/${clientId}/budget-settings`] 
      });
      
      // Reset form state to trigger refresh
      setFormInitialized(false);
      
      // Clear form dirty state
      form.reset(form.getValues());
      
      // Show appropriate success or error message
      if (updateSuccess && createSuccess && settingsUpdateSuccess) {
        toast({
          title: 'Success',
          description: 'Budget items updated successfully'
        });
      } else {
        toast({
          title: 'Partial Success',
          description: 'Some budget items may not have been updated correctly. Please check and try again.',
          variant: 'destructive'
        });
      }
    } catch (error) {
      console.error("Form submission error:", error);
      toast({
        title: 'Error',
        description: 'Failed to update budget items. Please try again.',
        variant: 'destructive'
      });
    }
  };

  // Loading state
  if (plansQuery.isPending) {
    return (
      <Card>
        <CardHeader>
          <CardTitle>Budget Management</CardTitle>
          <CardDescription>Loading budget information...</CardDescription>
        </CardHeader>
        <CardContent className="flex justify-center py-8">
          <Loader2 className="h-8 w-8 animate-spin text-primary" />
        </CardContent>
      </Card>
    );
  }

  // Error state
  if (plansQuery.isError) {
    return (
      <Card>
        <CardHeader>
          <CardTitle>Budget Management</CardTitle>
          <CardDescription>Error loading budget data</CardDescription>
        </CardHeader>
        <CardContent>
          <Alert variant="destructive">
            <AlertCircle className="h-4 w-4" />
            <AlertDescription>
              An error occurred while loading budget data. Please try again.
            </AlertDescription>
          </Alert>
        </CardContent>
      </Card>
    );
  }

  // No plans state
  if (plansQuery.data.length === 0) {
    return (
      <Card>
        <CardHeader>
          <CardTitle>Budget Management</CardTitle>
          <CardDescription>No budget plans available</CardDescription>
        </CardHeader>
        <CardContent>
          <Alert>
            <AlertDescription>
              There are no budget plans created for this client. 
              Please create a new budget plan to manage budget items.
            </AlertDescription>
          </Alert>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle>
          Budget Plan: {activePlan?.planCode || 'Default Plan'}
        </CardTitle>
        <CardDescription>
          Available Funds: {formatCurrency(
            activePlan && activePlan.availableFunds
              ? (typeof activePlan.availableFunds === 'string' 
                  ? parseFloat(activePlan.availableFunds) 
                  : activePlan.availableFunds)
              : 0
          )}
        </CardDescription>
      </CardHeader>
      <CardContent>
        <Form {...form}>
          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
            {/* Budget Validation */}
            <BudgetValidation 
              totalBudget={
                activePlan && activePlan.availableFunds
                ? (typeof activePlan.availableFunds === 'string'
                    ? parseFloat(activePlan.availableFunds)
                    : activePlan.availableFunds)
                : 0
              }
              totalAllocated={form.watch("totalAllocated") || 0}
              remainingBudget={form.watch("remainingBudget") || 0}
              originalAllocated={form.watch("totalBudget") || 0} // Use the client's budget amount
            />
            
            {/* Current Budget Items */}
            <div className="space-y-4">
              <h3 className="text-lg font-medium">Current Budget Allocations</h3>
              
              {fields.length === 0 ? (
                <div className="text-center py-4 text-gray-500">
                  No budget items added yet. Use the catalog selector below to add items.
                </div>
              ) : (
                <div className="space-y-2">
                  {fields.map((item, index) => (
                    <BudgetItemRow 
                      key={item.id || index}
                      item={item as unknown as RowBudgetItem}
                      index={index}
                      onUpdateQuantity={handleUpdateItemQuantity}
                      onDelete={handleDeleteItem}
                      allItems={fields.map(field => field as unknown as RowBudgetItem)}
                    />
                  ))}
                </div>
              )}
            </div>
            
            <Separator />
            
            {/* Catalog Item Selector */}
            <div className="space-y-4">
              <h3 className="text-lg font-medium">Add New Budget Item</h3>
              
              {catalogQuery.isPending ? (
                <div className="flex items-center justify-center py-4">
                  <Loader2 className="h-6 w-6 animate-spin text-gray-500" />
                </div>
              ) : catalogQuery.isError ? (
                <div className="p-4 border border-red-300 bg-red-50 rounded-md text-red-700">
                  Failed to load catalog items. Please try again.
                </div>
              ) : !catalogQuery.data ? (
                <div className="p-4 border border-amber-300 bg-amber-50 rounded-md text-amber-700">
                  No catalog items available. Please check your configuration.
                </div>
              ) : (
                <BudgetCatalogSelector 
                  catalogItems={catalogQuery.data || []}
                  onAddItem={handleAddCatalogItem}
                  remainingBudget={form.watch("remainingBudget") || 0}
                  activePlan={activePlan}
                />
              )}
            </div>
            
            <Separator />
            
            {/* Form Submission */}
            <div className="flex flex-col items-end gap-2">
              {/* Show notification about unsaved changes */}
              {(items.some(item => item.isNew) || form.formState.isDirty) && !saveMutation.isPending ? (
                <div className="mb-2 text-sm text-amber-600 font-medium p-2 bg-amber-50 border border-amber-200 rounded-md w-full text-center">
                  You have unsaved changes. Click the button below to save all changes.
                </div>
              ) : null}
              
              {/* Show saving indicator when in progress */}
              {saveMutation.isPending && (
                <div className="mb-2 text-sm text-blue-600 font-medium p-2 bg-blue-50 border border-blue-200 rounded-md w-full text-center flex items-center justify-center">
                  <Loader2 className="h-4 w-4 animate-spin mr-2" />
                  Saving your budget changes...
                </div>
              )}
              
              {/* Show success message after saving */}
              {saveMutation.isSuccess && !form.formState.isDirty && (
                <div className="mb-2 text-sm text-green-600 font-medium p-2 bg-green-50 border border-green-200 rounded-md w-full text-center">
                  All changes have been saved successfully.
                </div>
              )}
              
              {/* Check if we have any items to save or form is dirty before enabling save button */}
              <Button 
                type="submit" 
                disabled={
                  saveMutation.isPending || 
                  !formInitialized || 
                  (items.length === 0) || 
                  (!items.some(item => item.isNew) && !form.formState.isDirty)
                }
                size="lg"
                className="px-8"
              >
                {saveMutation.isPending ? (
                  <div className="flex items-center">
                    <Loader2 className="h-4 w-4 animate-spin mr-2" />
                    Saving Changes...
                  </div>
                ) : 'Save All Changes'}
              </Button>
            </div>
          </form>
        </Form>
      </CardContent>
    </Card>
  );
}